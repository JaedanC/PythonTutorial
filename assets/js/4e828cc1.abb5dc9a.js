"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[902],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),m=p(n),d=r,h=m["".concat(s,".").concat(d)]||m[d]||c[d]||o;return n?a.createElement(h,i(i({ref:t},u),{},{components:n})):a.createElement(h,i({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[m]="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},264:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>c,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const o={sidebar_position:4},i="Advanced",l={unversionedId:"Advanced",id:"Advanced",title:"Advanced",description:"This document will go over the most complicated concepts:",source:"@site/docs/Advanced.md",sourceDirName:".",slug:"/Advanced",permalink:"/PythonTutorial/docs/Advanced",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Advanced.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Intermediate",permalink:"/PythonTutorial/docs/Intermediate"},next:{title:"Crossword Solver",permalink:"/PythonTutorial/docs/Crossword Solver"}},s={},p=[{value:"Recursion",id:"recursion",level:2},{value:"Another example",id:"another-example",level:3},{value:"Magic methods",id:"magic-methods",level:2},{value:"The good",id:"the-good",level:3},{value:"How many are there",id:"how-many-are-there",level:3},{value:"Cursed?",id:"cursed",level:3},{value:"Iterators",id:"iterators",level:2},{value:"Generators",id:"generators",level:2},{value:"List Comprehensions",id:"list-comprehensions",level:2},{value:"Nesting them",id:"nesting-them",level:3},{value:"Dictionaries too",id:"dictionaries-too",level:3}],u={toc:p},m="wrapper";function c(e){let{components:t,...n}=e;return(0,r.kt)(m,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"advanced"},"Advanced"),(0,r.kt)("p",null,"This document will go over the most complicated concepts:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Recursion"),(0,r.kt)("li",{parentName:"ul"},"Magic methods"),(0,r.kt)("li",{parentName:"ul"},"Iterators"),(0,r.kt)("li",{parentName:"ul"},"Generators"),(0,r.kt)("li",{parentName:"ul"},"List Comprehensions"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"in")," operator"),(0,r.kt)("li",{parentName:"ul"},"Lambda expressions"),(0,r.kt)("li",{parentName:"ul"},"Performance")),(0,r.kt)("h2",{id:"recursion"},"Recursion"),(0,r.kt)("p",null,"Recursion is the act of running the same thing:"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Recursion is the act of running the same thing:"),(0,r.kt)("blockquote",{parentName:"blockquote"},(0,r.kt)("p",{parentName:"blockquote"},"Recursion is the act of running the same thing:"),(0,r.kt)("blockquote",{parentName:"blockquote"},(0,r.kt)("p",{parentName:"blockquote"},"Recursion is the act of running the same thing:"),(0,r.kt)("blockquote",{parentName:"blockquote"},(0,r.kt)("p",{parentName:"blockquote"},"Recursion is the act of running the same thing:"),(0,r.kt)("blockquote",{parentName:"blockquote"},(0,r.kt)("p",{parentName:"blockquote"},"Recursion is the act of running the same thing:")))))),(0,r.kt)("p",null,'Recursion is specifically to do with functions and how you can call them. Understanding recursion though first requires you to understand what "The Stack" is. Whenever a functions is called in Python, the existing state of the program is stored in a place in memory called the stack. I will represent the stack as a table.'),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Frame"),(0,r.kt)("th",{parentName:"tr",align:null},"Stack"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null})))),(0,r.kt)("p",null,"Currently the stack is empty. Let's write a sample program to show this stack."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def first(number):\n    number += 5\n    return number\n\ndef second(blah):\n    blah += 7\n    blah = first(blah)\n    return blah\n\nprint(second(10))\n")),(0,r.kt)("p",null,"Evaluating the execution of ",(0,r.kt)("inlineCode",{parentName:"p"},"second(10)")," is a little complicated, so let's follow it using using stack."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"second() is called. The main execution is paused and placed on the stack:")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Frame"),(0,r.kt)("th",{parentName:"tr",align:null},"Stack"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"@ main line 9")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Then in second() is called first() is called")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Frame"),(0,r.kt)("th",{parentName:"tr",align:null},"Stack"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"@ main line 9")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"@ second line 38")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Then when first() returns, the old state is popped from the stack.")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Frame"),(0,r.kt)("th",{parentName:"tr",align:null},"Stack"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"@ main line 9")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Then when second() returns, the old state is popped from the stack.")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Frame"),(0,r.kt)("th",{parentName:"tr",align:null},"Stack"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null})))),(0,r.kt)("p",null,'This "Stack" is a real thing that under the hood keeps track of the variables and location of execution so that when a function returns, it knows where to resume the execution from.'),(0,r.kt)("p",null,"So here comes the fun part. Recursion. You can call the same function, from inside the function."),(0,r.kt)("p",null,"For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def my_function(a, b):\n    print(a, b)\n    return my_function(a, b + 1)\n\nprint(my_function(1, 2))\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'1 2\n1 3\n1 4\n...\n1 994\n1 995\n1 996\nTraceback (most recent call last):\n  File "<stdin>", line 3, in my_function\n  [Previous line repeated 992 more times]\nRecursionError: maximum recursion depth exceeded while calling a Python object\n')),(0,r.kt)("p",null,"Ah dang. We hit a Stack Overflow. Our stack got too big. We kept calling the function too many times and didn't let the function close. This is kinda like an infinite loop, but this one results in us eating all the resources of the computer until it crashes. Not great."),(0,r.kt)("p",null,'So this introduces us to the first key part in any recursive function. The exit strategy. This is also referred to as the "Base Case". How are we going to make sure the function has a stopping point. Consider the following:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'def my_function(a, b):\n    if b == 100:\n        return "Done"\n    \n    print(a, b)\n    return my_function(a, b + 1)\n\nprint(my_function(1, 2))\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"1 1\n1 2\n1 3\n...\n1 97\n1 98\n1 99\n'Done'\n")),(0,r.kt)("p",null,"Nice. This time, the stack was able to close because I gave it an exit strategy when b == 100. Depending on what you want a recursive function to do, the exit strategy (or more multiple strategies) may be different."),(0,r.kt)("p",null,"One of the best cases for recursion is when searching a tree-like data structure. Below is an example of such a structure, and then how a recursive function may work to traverse the structure."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class Node:\n    def __init__(self, left, right):\n        self.left = left\n        self.right = right\n\n#                root\n#               /    \\\n#              /      \\\n#             /        \\\n#            /          \\\n#           /            \\\n#          /              \\\n#         /\\              /\\\n#        /  \\            /  \\\n#       /    \\          /    \\\n#      /      \\        /      7\n#     /\\      /\\      /\\\n#    /  \\    /  \\    /  \\\n#   0    5  8    4  6    2\n\nroot = \\\n    Node(\n        Node(\n            Node(0, 5),\n            Node(8, 4)\n        ),\n        Node(\n            Node(6, 2),\n            7\n        )\n    )\n\ndef print_all_nodes(node):\n    # Base case\n    if not isinstance(node, Node):\n        print(node)\n        return\n    \n    # The recursive case\n    print_all_nodes(node.left)\n    print_all_nodes(node.right)\n\nprint_all_nodes(root)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"$ python nodes.py\n0\n5\n8\n4\n6\n2\n7\n")),(0,r.kt)("h3",{id:"another-example"},"Another example"),(0,r.kt)("p",null,"There will not be a task for this topic, as it is very situational. And often a recursive implementation can be done without recursion, with better performance. Usually the trade-off though is that a recursive solution may be elegant. The following recursive function breaks down an integer into a list of it's smallest factors."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def get_factors(number):\n    # The recursive case is first.\n    # If the number is divisible this should run.\n    for i in range(2, number):\n        if number % i == 0:\n            return get_factors(i) + get_factors(number // i)\n    \n    # This is the base case. Is run when the number is\n    # not divisible. Rare to see the base case after the\n    # recursive case but it makes sense here.\n    return [number]\n\nprint(get_factors(2520))\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"$ python factors.py\n[2, 2, 2, 3, 3, 5, 7]\n")),(0,r.kt)("h2",{id:"magic-methods"},"Magic methods"),(0,r.kt)("p",null,"In python there are some really cool ways to make your classes behave differently when exposed to various operations. These are done using ",(0,r.kt)("em",{parentName:"p"},"Magic methods"),". These are special ",(0,r.kt)("inlineCode",{parentName:"p"},"__double_underscore__")," methods that when overwritten can override the default behaviour."),(0,r.kt)("p",null,"In this section we'll go over some of my favourite megic methods, where to find a list of them, and some truely cursed things we can do with them."),(0,r.kt)("h3",{id:"the-good"},"The good"),(0,r.kt)("p",null,"My favourite magic method is ",(0,r.kt)("inlineCode",{parentName:"p"},"__repr__()"),". This method is responsible for converting an instance to a string. If you've ever tried printing an instance of a class you've made you might see something like this."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'class Game:\n    def __init__(self, name, age_rating, platforms):\n        self.name = name\n        self.age_rating = age_rating\n        self.platforms = platforms\n\ndeep_rock = Game("Deep Rock Galatic", 16, ["PC", "Xbox"])\nprint(deep_rock)\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"$ python magic.py\n<__main__.Game object at 0x000002199EA37D60>\n")),(0,r.kt)("p",null,"This isn't particularly useful. Thankfully we can override this behaviour by defining a ",(0,r.kt)("inlineCode",{parentName:"p"},"__repr__")," method."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'class Game:\n    def __init__(self, name, age_rating, platforms):\n        self.name = name\n        self.age_rating = age_rating\n        self.platforms = platforms\n\n    def __repr__(self):\n        # This method expects a string to be returned\n        output = f"Game: {self.name}\\n" + \\\n            f"Age Rating: {self.age_rating}\\n" + \\\n            f"Platforms: {self.platforms}"\n        return output\n\ndeep_rock = Game("Deep Rock Galatic", 16, ["PC", "Xbox"])\nprint(deep_rock)\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"$ python magic.py\nGame: Deep Rock Galatic  \nAge Rating: 16\nPlatforms: ['PC', 'Xbox']\n")),(0,r.kt)("p",null,"This is substantially better! Another common magic method that I like to override is ",(0,r.kt)("inlineCode",{parentName:"p"},"__add__"),". This one allows you to define what happens when you added something to this. This method has a parameter. The parameter is what they are trying to add to the instance. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'deep_rock = Game("Deep Rock Galatic", 16, ["PC", "Xbox"])\nsession = deep_rock + Player("James", 20, ["Xbox"])\n')),(0,r.kt)("p",null,"This could be a great way to combine two custom objects, or create a new one from a combination. Just note that the type of the second object is usually not known, so unless you use ",(0,r.kt)("inlineCode",{parentName:"p"},"isinstance()")," you will have to guess. Here is an example where I create a class to represent a vector."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'class Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, other):\n        return Vector(self.x + other.x, self.y + other.y)\n    \n    def __repr__(self):\n        return f"Vector({self.x}, {self.y})"\n\n\nresult = Vector(5, 80) + Vector(10, -30)\nprint(result)\n')),(0,r.kt)("p",null,"In the example above I've assumed the second object will be other vectors. And then returned a new Vector from the result."),(0,r.kt)("h3",{id:"how-many-are-there"},"How many are there"),(0,r.kt)("p",null,"A good way to find out is by running ",(0,r.kt)("inlineCode",{parentName:"p"},"dir(int)"),". This will show you all the methods that are inherited by the ",(0,r.kt)("inlineCode",{parentName:"p"},"int")," class. Googling any specific method will give you useful information."),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://www.tutorialsteacher.com/python/magic-methods-in-python"},"https://www.tutorialsteacher.com/python/magic-methods-in-python")),(0,r.kt)("h3",{id:"cursed"},"Cursed?"),(0,r.kt)("p",null,"Overwriting magic methods allows you to produce some truely cursed behaviour."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'class Number:\n    def __init__(self, value):\n        self.value = value\n    \n    def __add__(self, other):\n        return Number(self.value - other.value)\n\n    def __repr__(self):\n        return f"Number({self.value})"\n\n\nresult = Number(5) + Number(3)\nprint(result)\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"$ python cursed.py\nNumber(2)\n")),(0,r.kt)("p",null,"With great power comes great responsbility. We've only touched on a few of the magic methods in Python. I encourage you to investigate using more of them in your code if it makes sense to do so."),(0,r.kt)("h2",{id:"iterators"},"Iterators"),(0,r.kt)("p",null,"An iterator is a promise. If I ask for something, you'll give me something. If I ask for the next thing, you'll give me the next thing. If you run out of things to give me, tell me, I'll stop."),(0,r.kt)("p",null,'This is how iterators work internally. When you try to "iterate" over a data-type in python it will look for a iterator promise/contract on that type. If it can\'t find one, it errors. We can easily reproduce this by trying to iterate over an integer.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"for element in 5:\n    pass\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"Traceback (most recent call last):     \n  File \"<stdin>\", line 1, in <module>\nTypeError: 'int' object is not iterable\n")),(0,r.kt)("p",null,"This is where our magic methods come in. Some types in python have the method method ",(0,r.kt)("inlineCode",{parentName:"p"},"__iter__")," implemented. This is the method that is called whenever is iterator is initially requested. After that, the ",(0,r.kt)("inlineCode",{parentName:"p"},"__next__")," method is called on the object that is returned by ",(0,r.kt)("inlineCode",{parentName:"p"},"__iter__"),". Let me give you an example. Let's create a class that represents a list, but when iterated, will iterate backwards."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class ReverseList:\n    def __init__(self, contents):\n        self.contents = contents\n    \n    def __iter__(self):\n        self.n = len(self.contents)\n        return self\n    \n    def __next__(self):\n        self.n -= 1\n        if self.n < 0:\n            raise StopIteration\n        return self.contents[self.n]      \n\nmy_list = ReverseList([1, 2, 3, 4])\n\nfor number in my_list:\n    print(number)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"$ python reverse_list.py\n4\n3\n2\n1\n")),(0,r.kt)("p",null,"This is how we read the code:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"When ",(0,r.kt)("inlineCode",{parentName:"li"},"for number in my_list")," is first called, ",(0,r.kt)("inlineCode",{parentName:"li"},"my_list.__iter__()")," is implicitly run to initialise the data structure to be iterated and to return the instance that contains the ",(0,r.kt)("inlineCode",{parentName:"li"},"__next__")," method."),(0,r.kt)("li",{parentName:"ol"},"Then, the ",(0,r.kt)("inlineCode",{parentName:"li"},"my_list.__next__()")," method is continously called to retrieve the next element. In this method I return the next element of the list working backwards."),(0,r.kt)("li",{parentName:"ol"},"When the list has been completely iterated over, I raise StopIteration which is a special error that python will silently catch. This tells python that ",(0,r.kt)("inlineCode",{parentName:"li"},"for number in my_list")," has fully evaluated.")),(0,r.kt)("p",null,"Now, technically there's nothing stopping you from returning something other than self in the ",(0,r.kt)("inlineCode",{parentName:"p"},"__iter__")," method. It's not common but here's a reason to do it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'class NormalIter:\n    def ready(self, contents):\n        self.contents = contents\n        self.n = 0\n\n    def __next__(self):\n        if self.n < len(self.contents):\n            element = self.contents[self.n]\n            self.n += 1\n            return element\n        raise StopIteration\n\nclass ReverseIter:\n    def ready(self, contents):\n        self.contents = contents\n        self.n = len(self.contents) - 1\n\n    def __next__(self):\n        if self.n >= 0:\n            element = self.contents[self.n]\n            self.n -= 1\n            return element\n        raise StopIteration\n\nclass MyList:\n    def __init__(self, contents, iterator):\n        self.contents = contents\n        self.iterator = iterator\n    \n    def __iter__(self):\n        self.iterator.ready(self.contents)\n        return self.iterator\n\nforwards = MyList([1, 2, 3, 4], NormalIter())\nbackwards = MyList([1, 2, 3, 4], ReverseIter())\n\nprint("Forwards")\nfor num in forwards:\n    print(num)\n\nprint("Backwards")\nfor num in backwards:\n    print(num)\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"Forwards\n1        \n2        \n3        \n4        \nBackwards\n4        \n3        \n2        \n1 \n")),(0,r.kt)("p",null,"As you can see we have decoupled the object and the iterator. This concept can be extended to traverse all kinds of weird data structures in many different ways."),(0,r.kt)("h2",{id:"generators"},"Generators"),(0,r.kt)("p",null,"These work similarly to iterators but completely differently also. Generators introduce a new keyword ",(0,r.kt)("inlineCode",{parentName:"p"},"yield"),". Before we move on, I need to stress that many people get confused between ",(0,r.kt)("inlineCode",{parentName:"p"},"return")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"yield"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"yield")," keyword is completely different to return and it only present in Python. This is why it is generally never spoken about. I have personally never written a generator, but knowing that they exist can be helpful."),(0,r.kt)("p",null,"A generator allows you to create a function and treat it like an iterator. Though typically as the name suggests, rather than iterating over something, it instead is generating some sequence. Let me give you an example generator where I mimic the bahaviour of range()."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'def my_range(start, end):\n    i = start\n    while i < end:\n        yield i\n        i += 1\n\n\nfor number in my_range(1, 5):\n    print(number)\n\nprint("Done")\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"$ python generator.py\n1\n2\n3\n4\n")),(0,r.kt)("p",null,"What is happening here is very weird. The yield keyword acts like a return, but when the function is called again, it resumes execution immediately at the yield statement resuming execution from yield. The generator is considered consumed when the function returns normally. In the example above it's when the ",(0,r.kt)("inlineCode",{parentName:"p"},"while")," loop completes."),(0,r.kt)("p",null,"I'm not going to talk about yield any more than that. If you really need a generator then you're probably fine looking up the details yourself. If you are still trying to grapple with functions themselves, then please just ignore that yield exists completely to avoid confusion. ",(0,r.kt)("strong",{parentName:"p"},"return"),", ",(0,r.kt)("strong",{parentName:"p"},"return"),", ",(0,r.kt)("strong",{parentName:"p"},"return"),"."),(0,r.kt)("h2",{id:"list-comprehensions"},"List Comprehensions"),(0,r.kt)("p",null,"Now we are truely getting into powerful lazy territory. List comprehensions are a feature in Python that let you create lists in one line of code that may normally take 2 or more. Most simple list idioms can be replaced by a list compreshension. But beware, just because it's shorter, does not mean it is better. They can sometimes be hard to read."),(0,r.kt)("p",null,"Normally, we might construct a list like so:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"foo = []\nfor number in range(10):\n    foo.append(number ** 2)\nprint(foo)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n")),(0,r.kt)("p",null,"This can be shortened using list comprehensions like so:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"foo = [number ** 2 for number in range(10)]\nprint(foo)\n")),(0,r.kt)("p",null,"What this is doing is unpacking ",(0,r.kt)("inlineCode",{parentName:"p"},"range()")," and then the results of ",(0,r.kt)("inlineCode",{parentName:"p"},"number ** 2")," will automatically be appended to the list. This is the essence of list comprehensions. They allow you to quickly unpack a for loop's calculation into a list. Here is another example, but a little more complicated."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'friends = ["James", "Bob", "Tim", "Josh", "Jim"]\n\nj_names = []\nfor name in friends:\n    if name.startswith("J"):\n        j_names.append(name)\n')),(0,r.kt)("p",null,"This for loop introduces an ",(0,r.kt)("inlineCode",{parentName:"p"},"if")," expression. List comprehensions can account for this like so:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'friends = ["James", "Bob", "Tim", "Josh", "Jim"]\nj_names = [name for name in friends if name.startswith("J")]\n')),(0,r.kt)("p",null,"With this understanding, this is how you read a list comprehension:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"result = [item.do_something() for item in collection if condition]\n")),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"What ",(0,r.kt)("inlineCode",{parentName:"li"},"collection")," do you want to loop over and what variable should we store each ",(0,r.kt)("inlineCode",{parentName:"li"},"item")," in?"),(0,r.kt)("li",{parentName:"ol"},"What are you going to do with the ",(0,r.kt)("inlineCode",{parentName:"li"},"item"),"?"),(0,r.kt)("li",{parentName:"ol"},"Should we ignore any items that do not satisfy a condition?")),(0,r.kt)("h3",{id:"nesting-them"},"Nesting them"),(0,r.kt)("p",null,"Since list comprehensions evaluate to a list, there's nothing stopping us from nesting list comprehensions. I would advise against aggresively doing this though because it can become hard to read very quickly, but as dirty one-liners go nested list comprehensions is right up there."),(0,r.kt)("p",null,"Consider this example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"grid = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\n\ndoubled = [[value * 2 for value in row] for row in grid]\nprint(doubled)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"[[2, 4, 6], [8, 10, 12], [14, 16, 18]]\n")),(0,r.kt)("p",null,"To do the same thing in a for loop would require:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"doubled = []\nfor row in grid:\n    current = []\n    for value in row:\n        current.append(value * 2)\n    grid.append(current)\n\n")),(0,r.kt)("p",null,"This is a good example of when a list comprehension may be easier to read than a ",(0,r.kt)("inlineCode",{parentName:"p"},"for")," loop."),(0,r.kt)("h3",{id:"dictionaries-too"},"Dictionaries too"),(0,r.kt)("p",null,"Dictionary comprehesions work too, and their format is similar but different. To create an entry in a dictionary you need both a key and a value. Consider the following example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'friends = ["James", "Bob", "Tim", "Josh", "Jim"]\nnumbered = {i : name for i, name in enumerate(friends)}\nprint(numbered)\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"{0: 'James', 1: 'Bob', 2: 'Tim', 3: 'Josh', 4: 'Jim'}\n")),(0,r.kt)("p",null,"Here we can see that I have created a dictionary whose keys are numerical and values are the names of the friends. A conditional can be added too like the list comprehensions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'friends = ["James", "Bob", "Tim", "Josh", "Jim"]\nnumbered = {i : name for i, name in enumerate(friends) if name.startswith("J") and i % 2 == 0}\nprint(numbered)\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"{0: 'James', 4: 'Jim'}\n")),(0,r.kt)("p",null,"Here you can see I've filtered both using ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"i"),", but any valid condition works too."))}c.isMDXComponent=!0}}]);